# 책 추천

- java concurrency in practice
- Effective Java의 Concurrency 장
- Modern Java in Action
- JavaNetWork programming
 
## 동시성

쓰레드를 내부로 감춰놓고 외부에서 편하게 쓸 수 있는 도구가 필요합니다. 

- `Future , Promise , Async, Observerble`
- 포크조인프레임워크

 Concurrent API에서 ExecutorService라는 개념이 도입됐다. 스레드를 직접적으로 다루는 가장 최상위 API로 앞으론 Thread 대신 이놈을 사용한다. Thread 다음 버전이라 생각하면 된다. Executors는 작업(task)들을 비동기적으로 실행시킬 수 있으며 기본적으로 스레드 풀을 운영한다. 따라서 우리는 스스로 스레드를 만들 필요가 전.혀. 없다. 스레드 풀의 스레드를은 자신의 임무를 다 마친 스레드들을 응당 재사용한다. 그렇기에 하나의 executor service를 이용하여 응용프로그램이 시작하고 끝날 때까지 우리가 원하는 만큼 `병렬용 작업` 을 만들고 실행시킬 수 있다.

`synchronized(동기화) 블록은 같은 객체에 대해 동기화하는 모든 코드를 병렬이 아닌 순서대로 실행되도록 한다.`

synchronized 블록을 대체하는 다른 것을 찾는다면, java.util.concurrent 패키지의 많은 원자성 데이터 타입들을 사용할 수도 있다. 에를 들자면 AtomicLong 이나 AtomicReference 와 같은 것들이다.

synchronized 블록과 대상 객체를 잡는 기준은 '가능한 좁은 범위'가 우선 원칙이 될만하다.

따라서, 실제 코드에서는 synchronized를 메서드에 적용하기 보다는 자바 5부터 추가된 Lock을 이용해서 동시 접근을 제어하는 것이 더 안전한 코드를 만들 가능성을 높여준다고 할 수 있다.

내부적으로 자바는 소위 monitor라 불리는 개념을 동기화를 위해 사용한다. 역시 운영체제에서 알 수 있을 내용이며 monitor lock or intrinsic lock을 보면 나오고 지금 당장 몰라도 된다고 치자. 이 모니터는 한 객체에 바인딩 되는데 메서드에 동기화를 걸게 되면 각 메서드는 해당 상응하는 객체에 대해 동일한 모니터를 공유한다.

## 자바 모니터

자바의 모든 객체는 모니터를 사용할 수 있다. 

synchronized 키워드를 통해서 배타동기를 제공하고, 자바의 최상위 객체 Object의 기본 메소드

notify, wait, notifyAll로 조건동기를 제공한다.

http://blog.naver.com/PostView.nhn?blogId=gngh0101&logNo=221174237333&parentCategoryNo=&categoryNo=25&viewDate=&isShowPopularPosts=false&from=postView

http://happinessoncode.com/2017/10/04/java-intrinsic-lock/ (모니터락 monitor lock 과 고유 락 (intrinsic lock))

## 참고

> https://hamait.tistory.com/748 [HAMA 블로그]
>
> https://hyojabal.tistory.com/2 [Java8 Concurrency와 ExecutorService에 대해]
>
> https://hyojabal.tistory.com/3?category=770091 [synchronized, semaphore 등]
>
> https://www.slipp.net/questions/179 [자바지기]

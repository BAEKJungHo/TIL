# 하나의 파일을 공유해서 읽고 쓰는 경우 동시성 이슈가 발생할까

> https://gamlor.info/posts-output/2019-11-27-write-coordination/en/
> 
> https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/java-intrinsic-locks.html

## 문제

주말에 [OKKY](https://okky.kr/article/1182177) 에서 QNA 답변을 해주다가, 한 번 생각해보면 좋을 주제가 있어서 공유해드립니다.

동시성 이슈와 관련된 문제 입니다.

그럼 문제 나갑니다~

- 빈(Bean)으로 등록되어있는 Service 에서 파일 쓰기 읽기 작업(writeAndRead())을 하는 메서드(파일을 먼저 쓰고 -> 읽는 작업을 수행 하는 메서드)를 제공하고 있으며,
- 여러 Thread 가 하나의 파일(Ex. file.txt)을 가지고 읽기 쓰기 작업을 수행 중이라고 할 때(파일 쓰기 작업을 하기 위해서 Writer 객체를 사용)

1. 동시성 이슈가 발생할지, 발생하지 않을지에 대해서 이유를 설명하시오. 
2. 읽기 작업에 대해서 일관성이 보장이 되는지, 되지 않는지에 대해서 이유를 설명하시오.

## writer 를 상태로 두고, 공유해서 사용하는 경우

```java
public class FileService {

    private final BufferedWriter writer;

    public FileService(BufferedWriter writer) throws Exception {
        this.writer = writer;
    }

    public void write(String contents) {
        File file = new File("D:\\file.txt");
        try {
            writer.write(contents);
            writer.flush();
            List<String> lines = Files.readAllLines(Paths.get("D:\\file.txt"));
            System.out.println(lines);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
 @Bean
    public ApplicationRunner appRunner() throws Exception {
        // FileService 를 싱글톤 처럼 객체 하나를 생성한 다음 각 스레드에서 공유하여 사용
        FileService fileService = new FileService(new BufferedWriter(new FileWriter("D:\\file.txt")));
        return args -> {
            Thread threadA = new Thread(() -> {
                try {
                    System.out.println("A call");
                    fileService.write("A");
                    System.out.println("A End");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            threadA.start();
            Thread threadB = new Thread(() -> {
                try {
                    System.out.println("B call");
                    fileService.write("B");
                    System.out.println("B End");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            threadB.start();
            Thread threadC = new Thread(() -> {
                try {
                    System.out.println("C call");
                    fileService.write("C");
                    System.out.println("C End");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            threadC.start();
        };
    }
```

- Writer 의 write 메서드에서는 synchronized lock 을 제공하므로 동시성 이슈는 발생하지 않는다.
- 대신, 결과는 ABC, ACB 등 먼저 파일 작업이 끝난 순서대로 된다. 파일에 문자열이 append 처럼 붙는 이유는 하나의 writer 를 공유하기 때문이다.
- Files.readAllLines 에서는 synchronized 가 없으므로 읽기 일관성을 얻지 못한다.

## writer 를 매개변수로 넘겨서 별도의 Stack Area 로 사용하는 경우

```java
public class FileService {

    public void write(String contents, BufferedWriter writer) {
        File file = new File("D:\\file.txt");
        try {
            writer.write(contents);
            writer.flush();
            List<String> lines = Files.readAllLines(Paths.get("D:\\file.txt"));
            System.out.println(lines);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
```java
@Bean
    public ApplicationRunner appRunner() throws Exception {
        FileService fileService = new FileService();
        return args -> {
            Thread threadA = new Thread(() -> {
                try {
                    System.out.println("A call");
                    fileService.write("A", new BufferedWriter(new FileWriter("D:\\file.txt")));
                    System.out.println("A End");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            threadA.start();
            Thread threadB = new Thread(() -> {
                try {
                    System.out.println("B call");
                    fileService.write("B", new BufferedWriter(new FileWriter("D:\\file.txt")));
                    System.out.println("B End");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            threadB.start();
            Thread threadC = new Thread(() -> {
                try {
                    System.out.println("C call");
                    fileService.write("C", new BufferedWriter(new FileWriter("D:\\file.txt")));
                    System.out.println("C End");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            threadC.start();
        };
    }
```

- 매개변수로 넘겨서 사용하면 별도의 stack area 가 생기므로, 동시성 이슈가 발생한다. 즉, 마지막에 작업이 끝난 Thread 를 기준으로 해당 문자열만 파일에 적혀있을 것이다.
- 읽기 일관성 또한 보장하지 못한다.
- __만약에 FileService 의 write 메서드에 synchronzied 를 적어주면 어떻게 될까?__
    - 동시성 이슈가 발생하지 않는다.
    - 읽기 일관성은 보장이 된다.
    - 별도의 writer 객체를 사용하기 때문에, Thread A - C - B 순서대로 작업을 하게되면 마지막에 끝난 Thread-B 를 기준으로 해당 문자열만 파일에 적혀있다.

## 결론

- 상태로 두어서 쓰던, 지역변수로 writer 를 넘겨서 쓰던 동시성 이슈는 발생하지 않는데 (writer 객체의 공유 여부에 따라서) 결과는 달라진다.
    - 원래 싱글톤 객체에서 상태를 두어서 사용하게 되면 동시성 이슈가 발생하는데, Writer 의 writer 에서는 synchronized 가 걸려있으므로 동시성 이슈가 발생하진 않는다.
- 물론, 실제로는 이러한 방식으로 사용하진 않을 것이다.
-

